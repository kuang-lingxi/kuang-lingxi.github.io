<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>react hooks的那些事 | buuug</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Blog">
    
    <link rel="preload" href="/assets/css/0.styles.a509abab.css" as="style"><link rel="preload" href="/assets/js/app.b8096a98.js" as="script"><link rel="preload" href="/assets/js/21.bf7b29c4.js" as="script"><link rel="preload" href="/assets/js/2.f7c58a73.js" as="script"><link rel="preload" href="/assets/js/20.6871ee84.js" as="script"><link rel="prefetch" href="/assets/js/10.9f899a40.js"><link rel="prefetch" href="/assets/js/11.2d977f36.js"><link rel="prefetch" href="/assets/js/12.6a78c77b.js"><link rel="prefetch" href="/assets/js/13.fbdd2dbb.js"><link rel="prefetch" href="/assets/js/14.a0e94ab5.js"><link rel="prefetch" href="/assets/js/15.14696e5f.js"><link rel="prefetch" href="/assets/js/16.b4d7f12b.js"><link rel="prefetch" href="/assets/js/17.a1268fee.js"><link rel="prefetch" href="/assets/js/18.e006a18f.js"><link rel="prefetch" href="/assets/js/19.dc652960.js"><link rel="prefetch" href="/assets/js/22.2b187d4a.js"><link rel="prefetch" href="/assets/js/23.b378ab73.js"><link rel="prefetch" href="/assets/js/24.7f821dca.js"><link rel="prefetch" href="/assets/js/25.3094cca7.js"><link rel="prefetch" href="/assets/js/26.b63bfa1d.js"><link rel="prefetch" href="/assets/js/27.05317306.js"><link rel="prefetch" href="/assets/js/28.5df471f1.js"><link rel="prefetch" href="/assets/js/29.460f4c4f.js"><link rel="prefetch" href="/assets/js/3.f9c8446f.js"><link rel="prefetch" href="/assets/js/30.dad3cbd3.js"><link rel="prefetch" href="/assets/js/31.f23cdcc2.js"><link rel="prefetch" href="/assets/js/32.b5d5a2db.js"><link rel="prefetch" href="/assets/js/33.af894eae.js"><link rel="prefetch" href="/assets/js/4.0bce2d4a.js"><link rel="prefetch" href="/assets/js/5.79fff311.js"><link rel="prefetch" href="/assets/js/6.ff667613.js"><link rel="prefetch" href="/assets/js/7.a5829279.js"><link rel="prefetch" href="/assets/js/8.61c949c0.js"><link rel="prefetch" href="/assets/js/9.968eca4f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a509abab.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">buuug</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专题列表" class="dropdown-title"><span class="title">专题列表</span> <span class="arrow down"></span></button> <button type="button" aria-label="专题列表" class="mobile-dropdown-title"><span class="title">专题列表</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/react/" class="nav-link router-link-active">
  react
</a></li><li class="dropdown-item"><!----> <a href="/css/" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/other/" class="nav-link">
  随便写写
</a></li><li class="dropdown-item"><!----> <a href="/chromium/" class="nav-link">
  chromium
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专题列表" class="dropdown-title"><span class="title">专题列表</span> <span class="arrow down"></span></button> <button type="button" aria-label="专题列表" class="mobile-dropdown-title"><span class="title">专题列表</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/react/" class="nav-link router-link-active">
  react
</a></li><li class="dropdown-item"><!----> <a href="/css/" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/other/" class="nav-link">
  随便写写
</a></li><li class="dropdown-item"><!----> <a href="/chromium/" class="nav-link">
  chromium
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/react/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/" class="sidebar-link">react渲染流程</a></li><li><a href="/react/componentDidMount/" class="sidebar-link">componentDidMount</a></li><li><a href="/react/diff/" class="sidebar-link">react的diff算法</a></li><li><a href="/react/hooks/" aria-current="page" class="active sidebar-link">react hooks</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/hooks/#hooks" class="sidebar-link">hooks</a></li><li class="sidebar-sub-header"><a href="/react/hooks/#hook的存储" class="sidebar-link">hook的存储</a></li><li class="sidebar-sub-header"><a href="/react/hooks/#hook的使用" class="sidebar-link">hook的使用</a></li><li class="sidebar-sub-header"><a href="/react/hooks/#hooks只能在顶层使用的原因" class="sidebar-link">hooks只能在顶层使用的原因</a></li><li class="sidebar-sub-header"><a href="/react/hooks/#hooks-如何实现一个函数组件能够记住之前的状态" class="sidebar-link">hooks 如何实现一个函数组件能够记住之前的状态</a></li><li class="sidebar-sub-header"><a href="/react/hooks/#结语" class="sidebar-link">结语</a></li></ul></li><li><a href="/react/react17-setState/" class="sidebar-link">react17的setState</a></li><li><a href="/react/react18-setState/" class="sidebar-link">react18的setState</a></li><li><a href="/react/useEffect/" class="sidebar-link">useEffect和useLayoutEffect</a></li><li><a href="/react/react%20useState%E7%9A%84%E8%87%AA%E5%8A%A8%E4%BC%98%E5%8C%96/" class="sidebar-link">react useState的自动优化</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-hooks的那些事"><a href="#react-hooks的那些事" class="header-anchor">#</a> react hooks的那些事</h1> <p>react hooks推出也有很长一段时间了, 我相信很多项目的代码里面都有着 <code>hooks</code> 的身影.那么你在用的时候有没有问过自己, 为什么一个函数能记住状态?为什么 <code>hook</code> 写在if else中会有 <code>warning</code> ?下面我们来一点点的扒一扒 <code>hook</code> 的实现原理.</p> <h2 id="hooks"><a href="#hooks" class="header-anchor">#</a> hooks</h2> <p>目前官方提供的 <code>hook</code> 有下面几种:</p> <h3 id="基础-hook"><a href="#基础-hook" class="header-anchor">#</a> 基础 Hook</h3> <ul><li>useState</li> <li>useEffect</li> <li>useContext</li></ul> <h3 id="额外的-hook"><a href="#额外的-hook" class="header-anchor">#</a> 额外的 Hook</h3> <ul><li>useReducer</li> <li>useCallback</li> <li>useMemo</li> <li>useRef</li> <li>useImperativeHandle</li> <li>useLayoutEffect</li> <li>useDebugValue</li></ul> <p>这些 <code>hook</code> 的作用可以参阅<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener noreferrer">官网文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, 他们实现的功能不外乎这几种:</p> <ol><li>在函数中可以记住当前状态</li> <li>实现缓存, 能够在整个生命周期内维持变量</li> <li>一些副作用操作可以根据某些条件判断是否执行</li> <li>实现了ref</li></ol> <p>我们用的最多的可能就是前面两种, 那么他们到底是如何实现这些功能的呢? 不慌, 我们今天就来探究一下. 首先用过 <code>hooks</code> 的人都知道, <code>hooks</code>有一个非常强要求的限制就是, 只能在函数顶层使用.</p> <div class="language- extra-class"><pre class="language-text"><code>React Hook &quot;useState&quot; is called conditionally. React Hooks must be called in the exact same order in every component render
</code></pre></div><p>我相信很多人都看见过这句话, 这是你没有在函数顶层使用 <code>hook</code> 的时候 <code>react</code> 抛出的一个错误, 那为什么 <code>react</code> 有这种限制呢?我们来看看 <code>react</code> 第一次创建 <code>hook</code> 时干了什么.</p> <h2 id="hook的存储"><a href="#hook的存储" class="header-anchor">#</a> hook的存储</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountMemo</span><span class="token punctuation">(</span><span class="token parameter">nextCreate<span class="token punctuation">,</span> deps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> nextDeps <span class="token operator">=</span> deps <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> deps<span class="token punctuation">;</span>
  <span class="token keyword">var</span> nextValue <span class="token operator">=</span> <span class="token function">nextCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token punctuation">[</span>nextValue<span class="token punctuation">,</span> nextDeps<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> nextValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>react</code> 在每个 <code>hook</code> 第一次运行时, 总会有一句</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个函数是在干嘛呢?</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hook <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">memoizedState</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">baseState</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">baseQueue</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">queue</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">next</span><span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">//workInProgressHook 是当前最新生成的 hook</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgressHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This is the first hook in the list</span>
    currentlyRenderingFiber$1<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> workInProgressHook <span class="token operator">=</span> hook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Append to the end of the list</span>
    workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> workInProgressHook<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到, 它新声明了一个 <code>hook</code> 对象, 里面各个值的含义我们暂且不去关心, 在后面的代码中, 先是判断了<code>workInprogressHook</code> 是否为空, 这个字段其实是指向了一个最新生成的 <code>hook</code> ,如果它为空, 证明我们是第一次生成 <code>hook</code> , 我们就把生成的 <code>hook</code> 赋值给 <code>workInProgressHook</code> 和 <code>currentlyRenderingFiber\$1.memoizedState</code>.（<code>currentlyRenderingFiber$1</code>是一个正在生成的 <code>FiberNode</code> 对象）.而如果已经生成过 <code>hook</code> 了, 那么我们就直接让当前 <code>hook</code> 的 <code>next</code> 等于下一个 <code>hook</code> , 再修改 <code>workInprogressHook</code> 为最新生成的 <code>hook</code> .这是典型的链表结构.我们用一张图来理解一下:</p> <img src="/assets/img/hooks.d2e65f83.png"> <p>我们知道 <code>react</code> 更新了 <code>fiber</code> 架构, 现在 <code>react</code> 渲染的时候会生成一颗<code>fiber</code>树, 这颗树由很多个<code>FiberNode</code>结点组成.<code>FiberNode</code> 中有一个属性就叫做 <code>memoizedState</code> .当然还有很多其他的属性, 为了排除干扰项我们就不列出来了.</p> <p><strong>注意:  <code>hook</code> 的数据结构中也有一个 <code>memoizedState</code>, 这两个不是同一个东西, 大家不要搞混了.</strong></p> <p>每个组件都会生成一个 <code>FiberNode</code> .每个组件内使用的 <code>hook</code> 会以链表的形式挂在 <code>FiberNode</code> 的 <code>memoizedState</code> 上面.而每个 <code>FiberNode</code> 汇聚起来会变成一颗 <code>Fiber</code> 树,  <code>React</code> 每次会以固定的顺序遍历这棵树, 这样就把整个页面的 <code>hook</code> 都串联起来了.</p> <p>所以, <code>mountWorkInProgressHook</code> 其实就是在做一个初始化的过程, 把  <code>hook</code> 挂载到结点上去, 再返回这个 <code>hook</code> .</p> <p>ps: <code>FiberNode</code> 也不只是单纯用这种单向的方式连接, 他们其实会有指向父结点和兄弟结点的指针, 同样为了减少干扰在此处没有表现出来.</p> <h2 id="hook的使用"><a href="#hook的使用" class="header-anchor">#</a> hook的使用</h2> <p>那么我们初始化 <code>hook</code> 之后, 再次 <code>render</code> 的时候会发生什么呢?</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateMemo</span><span class="token punctuation">(</span><span class="token parameter">nextCreate<span class="token punctuation">,</span> deps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> nextDeps <span class="token operator">=</span> deps <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> deps<span class="token punctuation">;</span>
  <span class="token keyword">var</span> prevState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>

  <span class="token operator">...</span>省略
<span class="token punctuation">}</span>
</code></pre></div><p>我们会发现, 每次开头都有一句</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>那这个函数又是在干什么</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// This function is used both for updates and for re-renders triggered by a</span>
  <span class="token comment">// render phase update. It assumes there is either a current hook we can</span>
  <span class="token comment">// clone, or a work-in-progress hook from a previous render pass that we can</span>
  <span class="token comment">// use as a base. When we reach the end of the base list, we must switch to</span>
  <span class="token comment">// the dispatcher used for mounts.</span>
  <span class="token keyword">var</span> nextCurrentHook<span class="token punctuation">;</span>

  <span class="token comment">// currentHook: 已经生成的 fiber 树上的 hook, 第一次是空</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// currentlyRenderingFiber$1: 正在生成的 FiberNode 结点, alternate 上挂载的是上一次已经生成完的 fiber 结点</span>
    <span class="token comment">// 所以 current 就是上次生成的 FiberNode</span>
    <span class="token keyword">var</span> current <span class="token operator">=</span> currentlyRenderingFiber$1<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 我们之前说过 hooks 挂在 FiberNode 的 memoizedState 上, 这里拿到第一个 hook</span>
      nextCurrentHook <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      nextCurrentHook <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不是第一次, 则证明已经拿到了 hook, 我们只需要用 next 就能找到下一个 hook</span>
    nextCurrentHook <span class="token operator">=</span> currentHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> nextWorkInProgressHook<span class="token punctuation">;</span>

  <span class="token comment">// workInProgressHook: 正在生成的 FiberNode 结点上的 hook, 第一次为空</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgressHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// currentlyRenderingFiber$1 是当前正在生成的 FiberNode</span>
    <span class="token comment">// 所以这里 nextWorkInProgressHook 的值就是当前正在遍历的 hook, 第一次让它等于 memoizedState</span>
    nextWorkInProgressHook <span class="token operator">=</span> currentlyRenderingFiber$1<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不是第一次, 始终让它指向下一个 hook, 如果这是最后一个, 那么 nextWorkInProgressHook 就会是 null</span>
    nextWorkInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextWorkInProgressHook <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// There's already a work-in-progress. Reuse it.</span>
    workInProgressHook <span class="token operator">=</span> nextWorkInProgressHook<span class="token punctuation">;</span>
    nextWorkInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    currentHook <span class="token operator">=</span> nextCurrentHook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不存在的话会根据上一次的 hook 克隆一个新的 hook, 挂在新的链表、FiberNode上.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>nextCurrentHook <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span> <span class="token string">&quot;Rendered more hooks than during the previous render.&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    currentHook <span class="token operator">=</span> nextCurrentHook<span class="token punctuation">;</span>
    <span class="token keyword">var</span> newHook <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">memoizedState</span><span class="token operator">:</span> currentHook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span>
      <span class="token literal-property property">baseState</span><span class="token operator">:</span> currentHook<span class="token punctuation">.</span>baseState<span class="token punctuation">,</span>
      <span class="token literal-property property">baseQueue</span><span class="token operator">:</span> currentHook<span class="token punctuation">.</span>baseQueue<span class="token punctuation">,</span>
      <span class="token literal-property property">queue</span><span class="token operator">:</span> currentHook<span class="token punctuation">.</span>queue<span class="token punctuation">,</span>
      <span class="token literal-property property">next</span><span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgressHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// This is the first hook in the list.</span>
      currentlyRenderingFiber$1<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> workInProgressHook <span class="token operator">=</span> newHook<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// Append to the end of the list.</span>
      workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> newHook<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> workInProgressHook<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我在代码中加了注释, 感兴趣的同学可以看看具体的代码, 下面我们大体解释一下这个函数干了什么.</p> <p>当 <code>react</code> 重新渲染时, 会生成一个新的 <code>fiber</code> 树, 而这里会根据之前已经生成的 <code>FiberNode</code>  , 拿到之前的  <code>hook</code>  , 再复制一份到新的  <code>FiberNode</code>  上, 生成一个新的 <code>hooks</code> 链表.</p> <p>而这个  <code>hook</code> 是怎么拿的?是去遍历 <code>hooks</code> 链表拿的, 所以每次都会按顺序拿下一个 <code>hook</code> , 然后复制到新的 <code>FiberNode</code> 上.可以理解为这个 <code>updateWorkInProgressHook</code> 每次都会按顺序返回下一个 <code>hook</code> .</p> <p>拿到这个 <code>hook</code> 之后再根据我们 <code>setState</code> 的值或者其他的一些东西去更新 <code>hook</code> 对象上的属性.这一步也就是 <code>updateMemo</code> 干的事情.</p> <h2 id="hooks只能在顶层使用的原因"><a href="#hooks只能在顶层使用的原因" class="header-anchor">#</a> hooks只能在顶层使用的原因</h2> <p>其实看到这里你就应该明白为什么 <code>hooks</code> 只能在顶层使用了, 因为它会按顺序去拿<code>hook</code>, <code>react</code>也是按顺序来区分不同的 <code>hook</code> 的, 它默认你不会修改这个顺序.如果你没有在顶层使用 <code>hook</code> , 打乱了每次 <code>hook</code> 调用的顺序, 就会导致 <code>react</code> 无法区分出对应的 <code>hook</code> , 进而导致错误.那你说, 如果我不在顶层使用 <code>hooks</code> , 但是我保证它每次都会被调用, 这样行不行?行, 但是为什么要给自己徒增烦恼去保证它每次都会被调用, 老老实实写在顶层不好吗?</p> <h2 id="hooks-如何实现一个函数组件能够记住之前的状态"><a href="#hooks-如何实现一个函数组件能够记住之前的状态" class="header-anchor">#</a> hooks 如何实现一个函数组件能够记住之前的状态</h2> <p>我们知道, 一个函数重复运行的时候它的变量都会被销毁, 那 <code>react</code> 为什么可以记住上次的变量?因为 <code>react</code> 帮我们把这些变量存了下来.我们之前说到,  <code>hook</code> 会以链表的形式被挂在 <code>FiberNode</code> 的 <code>memoizedState</code> 上, 你可以把  <code>FiberNode</code> 理解为一个全局变量, 它并不会被销毁.所以我们下次 <code>render</code> 的时候就能从这上面拿到上次的 <code>hook</code> , 自然也能拿到 <code>hook</code> 上携带的一些信息, 再根据这些信息去 <code>render</code> 新的组件, 就能实现函数组件也能有自己的状态了.而 <code>useState</code> , <code>useMemo</code> , <code>useRef</code> 这种带缓存效果的 <code>hooks</code> 的实现原理也显而易见了, 我们看一个简单的 <code>useMemo</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mountMemo</span><span class="token punctuation">(</span><span class="token parameter">nextCreate<span class="token punctuation">,</span> deps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hook <span class="token operator">=</span> <span class="token function">mountWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> nextDeps <span class="token operator">=</span> deps <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> deps<span class="token punctuation">;</span>
  <span class="token keyword">var</span> nextValue <span class="token operator">=</span> <span class="token function">nextCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token punctuation">[</span>nextValue<span class="token punctuation">,</span> nextDeps<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> nextValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在生成的时候, 就是简单的调用了一下 <code>create</code> 函数生成了初始值并返回.</p> <p>而在更新的时候</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">updateMemo</span><span class="token punctuation">(</span><span class="token parameter">nextCreate<span class="token punctuation">,</span> deps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hook <span class="token operator">=</span> <span class="token function">updateWorkInProgressHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> nextDeps <span class="token operator">=</span> deps <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> deps<span class="token punctuation">;</span>
  <span class="token keyword">var</span> prevState <span class="token operator">=</span> hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevState <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Assume these are defined. If they're not, areHookInputsEqual will warn.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextDeps <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> prevDeps <span class="token operator">=</span> prevState<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">areHookInputsEqual</span><span class="token punctuation">(</span>nextDeps<span class="token punctuation">,</span> prevDeps<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> prevState<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> nextValue <span class="token operator">=</span> <span class="token function">nextCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token punctuation">[</span>nextValue<span class="token punctuation">,</span> nextDeps<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> nextValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>会判断一下我们的 <code>deps</code> 依赖是否改变（这里最底层会使用 <code>Object.is</code> 来判断是否相等）,如果改变了, 那么再调用一下我们传入的  <code>create</code> 来返回最新的值, 如果没有改变, 那么就直接返回我们上次的值, 进而实现缓存的效果.</p> <p>怎么拿到上次的 <code>hook</code> ?就是通过我们之前说的<code>updateWorkInProgressHook</code>, 那怎么保证两次拿的 <code>hook</code> 是同一个?这就是靠顺序保证了.</p> <h2 id="结语"><a href="#结语" class="header-anchor">#</a> 结语</h2> <p>本文只是简单叙述了 <code>hooks</code> 背后的实现方式, 并没有对每个 <code>hook</code> 的具体实现方式做过多的阐述, 我相信大家在了解了基本原理之后再去看各个 <code>hook</code> 的实现方式就会简单很多了.同时我后面也会再出一些关于具体 <code>hook</code> 的实现方式解析, 和大家一起共同交流学习.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react/diff/" class="prev">
        react的diff算法
      </a></span> <span class="next"><a href="/react/react17-setState/">
        react17的setState
      </a>
      →
    </span></p></div>  <!----></main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b8096a98.js" defer></script><script src="/assets/js/21.bf7b29c4.js" defer></script><script src="/assets/js/2.f7c58a73.js" defer></script><script src="/assets/js/20.6871ee84.js" defer></script>
  </body>
</html>
