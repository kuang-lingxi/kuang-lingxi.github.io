(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{529:function(_,v,e){_.exports=e.p+"assets/img/npm2.7bf69ce9.png"},530:function(_,v,e){_.exports=e.p+"assets/img/npm3.624229b0.png"},531:function(_,v,e){_.exports=e.p+"assets/img/A&B.83e8d424.png"},532:function(_,v,e){_.exports=e.p+"assets/img/redundant.f7df0d93.png"},533:function(_,v,e){_.exports=e.p+"assets/img/image-15-1636814893552.3d26563b.png"},534:function(_,v,e){_.exports=e.p+"assets/img/image-16-1636814893753.863584b3.png"},535:function(_,v,e){_.exports=e.p+"assets/img/image-17-1636814894154.3955723b.png"},536:function(_,v,e){_.exports=e.p+"assets/img/image-18-1636814894557.c4b7bf53.png"},537:function(_,v,e){_.exports=e.p+"assets/img/image-19-1636814894959.7fed88a9.png"},538:function(_,v,e){_.exports=e.p+"assets/img/image-20-1636814895563.01933d03.png"},587:function(_,v,e){"use strict";e.r(v);var o=e(59),n=Object(o.a)({},(function(){var _=this,v=_.$createElement,o=_._self._c||v;return o("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[o("h1",{attrs:{id:"项目中node-modules里面的那些无用包"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#项目中node-modules里面的那些无用包"}},[_._v("#")]),_._v(" 项目中node_modules里面的那些无用包")]),_._v(" "),o("p",[_._v("相信大家在开发过程中执行"),o("code",[_._v("yarn")]),_._v("或者"),o("code",[_._v("npm i")]),_._v("的时候都会发现一个问题, 明明我的项目只依赖几个"),o("code",[_._v("npm")]),_._v("包, 但是执行完命令后"),o("code",[_._v("node_modules")]),_._v("里面却多出了超级多没见过的无用包?这就和依赖的处理方式有关了, 今天我们就来聊聊这部分的内容.")]),_._v(" "),o("h2",{attrs:{id:"npm2的依赖管理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#npm2的依赖管理"}},[_._v("#")]),_._v(" npm2的依赖管理")]),_._v(" "),o("p",[o("code",[_._v("npm2")]),_._v(" 安装依赖的时候比较简单直接, 直接按照包依赖的树形结构下载填充本地目录结构.\n比如在项目中 "),o("code",[_._v("A")]),_._v(" 和 "),o("code",[_._v("C")]),_._v(" 都依赖 "),o("code",[_._v("B")]),_._v(" , 无论被依赖的 "),o("code",[_._v("B")]),_._v(" 是否是同一个版本, 都会直接无脑的生成对应的树结构, 比如我们现在有下面的依赖:\nA@2.0.0: BaseA@1.0.0 BaseB@2.0.0\nB@3.0.0: BaseA@1.0.0 BaseB@2.0.1\n那么 "),o("code",[_._v("npm i")]),_._v(" 之后 "),o("code",[_._v("node_modules")]),_._v(" 里面生成的内容将是下面这样的")]),_._v(" "),o("p",[o("img",{attrs:{src:e(529),alt:""}})]),_._v(" "),o("p",[_._v("这样的结构非常直观, 但是有一个问题就是, 如果项目的依赖过多的话, 可能导致下面这些问题:")]),_._v(" "),o("ol",[o("li",[o("p",[_._v("生成的依赖嵌套非常深")])]),_._v(" "),o("li",[o("p",[_._v("相同版本的依赖大量冗余")])])]),_._v(" "),o("h2",{attrs:{id:"npm3-yarn的依赖管理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#npm3-yarn的依赖管理"}},[_._v("#")]),_._v(" npm3/yarn的依赖管理")]),_._v(" "),o("p",[o("code",[_._v("npm3")]),_._v(" 对于 "),o("code",[_._v("npm2")]),_._v(" 的情况进行了优化, 那么如何进行优化呢?其实我们最直观的思路就是将树打平, 将依赖扁平化, 不就能解决嵌套过深和依赖冗余的问题.所以, 在上面的例子中, 如果我们用 "),o("code",[_._v("npm3")]),_._v(" 来进行 "),o("code",[_._v("install")]),_._v(" , 最后生成的 "),o("code",[_._v("node_modules")]),_._v(" 会是这样的结构:")]),_._v(" "),o("p",[o("img",{attrs:{src:e(530),alt:""}})]),_._v(" "),o("p",[_._v("这样看起来是不是就好多了, 但是此时会有什么问题呢?我们实操一下试试看.在项目中安装 "),o("code",[_._v("A")]),_._v(" 和 "),o("code",[_._v("B")])]),_._v(" "),o("p",[o("img",{attrs:{src:e(531),alt:""}})]),_._v(" "),o("p",[_._v("可以看到我们项目本身的依赖文件里面只有 "),o("code",[_._v("a_klx")]),_._v(" 和 "),o("code",[_._v("b_klx")]),_._v(" , 但是执行完 "),o("code",[_._v("npm i")]),_._v(" 命令后却发现多了几个我们没有引入的包 "),o("code",[_._v("a_base_klx")]),_._v(" 和 "),o("code",[_._v("b_base_klx")]),_._v(" .\n其实这是由 "),o("code",[_._v("a_klx")]),_._v(" 和 "),o("code",[_._v("b_klx")]),_._v(" 本身自己引入的 "),o("code",[_._v("npm")]),_._v(" 包, 但是却出现在了我们的 "),o("code",[_._v("node_modules")]),_._v(" 下.那么如果我们直接使用这两个包会有什么反应呢?")]),_._v(" "),o("p",[o("img",{attrs:{src:e(532),alt:""}})]),_._v(" "),o("p",[_._v("可以看到, 我们是可以正常使用这两个我们并未声明在依赖中的 "),o("code",[_._v("npm")]),_._v(" 包的, 因为这两个包存在于我们项目的 "),o("code",[_._v("node_modules")]),_._v(" 下, 根据 "),o("code",[_._v("npm")]),_._v(" 包的查找规则, 我们是可以找到这两个包的.所以这种依赖关系就导致了下面两个问题:")]),_._v(" "),o("ol",[o("li",[o("p",[_._v("我们项目本身的 "),o("code",[_._v("node_modules")]),_._v(" 结构不够直观")])]),_._v(" "),o("li",[o("p",[_._v("依赖不安全, 我们可以使用依赖文件中并没有声明的 "),o("code",[_._v("npm")]),_._v(" 包")])])]),_._v(" "),o("p",[_._v("其实第一点的问题并不是很大, 主要是第二点可能会导致一些奇怪的问题.以我们之前的例子来说, 我们可以直接在项目里面直接使用 "),o("code",[_._v("a_base_klx")]),_._v(" , 因为 "),o("code",[_._v("node_modules")]),_._v(" 里面这两个包实际上是存在的, 但是他们又不是永远存在的.万一有一天,  "),o("code",[_._v("a_klx")]),_._v(" 和 "),o("code",[_._v("b_klx")]),_._v(" 里都去除了这两个基础包的引用,  "),o("code",[_._v("node_modules")]),_._v(" 里面将不再存在 "),o("code",[_._v("a_base_klx")]),_._v(" 和 "),o("code",[_._v("b_base_klx")]),_._v(" , 那么我们的代码就会出现问题...也就是:")]),_._v(" "),o("div",{staticClass:"custom-block danger"},[o("p",{staticClass:"custom-block-title"},[_._v("DANGER")]),_._v(" "),o("p",[_._v("我的代码啥也没动, 放了一个晚上就坏了​")])]),_._v(" "),o("p",[_._v("同时, 我们对于这种处理方式其实很容易有一个疑问, 如果我同时引用了同一个包的多个不同版本, 会帮我把哪个包提出来, 同时我每次 "),o("code",[_._v("npm i")]),_._v(" 之后提出来的包版本都是一样的吗?会不会存在这次是 "),o("code",[_._v("2.0.0")]),_._v(" 版本下次是 "),o("code",[_._v("2.0.1")]),_._v(" 版本的情况, 比如我们下面这种情况:\nA@1.0.0: BaseA@1.0.0 BaseB@2.0.0\nB@1.0.0: BaseA@1.0.0 BaseB@2.0.1\nD@1.0.0: BaseA@1.0.0 BaseB@2.0.1\n生成的依赖是下面这样的:")]),_._v(" "),o("p",[o("img",{attrs:{src:e(533),alt:""}})]),_._v(" "),o("p",[_._v("还是下面这样的:")]),_._v(" "),o("p",[o("img",{attrs:{src:e(534),alt:""}})]),_._v(" "),o("p",[_._v("其实看起来后面这个更合理, 因为有两个包用到了 "),o("code",[_._v("2.0.1")]),_._v(" 版本, 将它提出来更好, 我们实际操作一下试试:")]),_._v(" "),o("p",[o("img",{attrs:{src:e(535),alt:""}})]),_._v(" "),o("p",[_._v("被提到最外层的包是 "),o("code",[_._v("2.0.0")]),_._v(" 版本的, 然后 "),o("code",[_._v("b_klx")]),_._v(" 和 "),o("code",[_._v("d_klx")]),_._v(" 的 "),o("code",[_._v("node_modules")]),_._v(" 下面各自有一个 "),o("code",[_._v("b_base_klx@2.0.1")]),_._v("\n这一块的内容自己查了一下, 大部分说法是会根据 "),o("code",[_._v("package.json")]),_._v(" 里面的顺序决定谁会被提出来, 放在前面的包依赖的内容会被先提出来.")]),_._v(" "),o("p",[o("img",{attrs:{src:e(536),alt:""}})]),_._v(" "),o("p",[_._v("不过自己实操了一下发现并不是这样, 即使我把 "),o("code",[_._v("b_klx")]),_._v(" 或者 "),o("code",[_._v("d_klx")]),_._v(" 移到最前面, 被提出来的包依然是 "),o("code",[_._v("a_klx")]),_._v(" 依赖的 "),o("code",[_._v("2.0.0")]),_._v(" 版本, 随后自己翻了一下 "),o("code",[_._v("npm")]),_._v(" 的源码, 发现内部其实会对拿到的依赖列表进行一些处理\n"),o("img",{attrs:{src:e(537),alt:""}}),_._v("\n最终会通过 "),o("code",[_._v("localeCompare")]),_._v(" 方法对依赖进行一次排序, 所以字典序在前面的 "),o("code",[_._v("npm")]),_._v(" 包的底层依赖会被优先提出来, 对于我们的例子来说就是 "),o("code",[_._v("a_klx")]),_._v(" 所依赖的 "),o("code",[_._v("b_base_klx@2.0.0")]),_._v(" 会被优先提出来.")]),_._v(" "),o("h2",{attrs:{id:"pnpm的依赖管理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#pnpm的依赖管理"}},[_._v("#")]),_._v(" pnpm的依赖管理")]),_._v(" "),o("p",[o("code",[_._v("pnpm")]),_._v(" 为了解决上述这些问题, 采用了一种不同于 "),o("code",[_._v("npm/yarn")]),_._v(" 的依赖管理方式.")]),_._v(" "),o("p",[_._v("如果我们用 "),o("code",[_._v("pnpm")]),_._v(" 再来安装一遍上面的依赖, 会发现项目的 "),o("code",[_._v("node_modules")]),_._v(" 文件夹只有当前 "),o("code",[_._v("package.json")]),_._v(" 中所声明的各个依赖（的软连接）, 而真正的模块文件, 存在于 "),o("code",[_._v("node_modules/.pnpm")]),_._v(" , 由 "),o("code",[_._v("模块名@版本号")]),_._v(" 形式的文件夹扁平化存储(解决依赖重复安装).同时这样设计, 也很好的避免了之前可以访问非法 "),o("code",[_._v("npm")]),_._v(" 包的问题, 因为当前项目的 "),o("code",[_._v("node_modules")]),_._v(" 只有我们声明过的依赖, 这也让 "),o("code",[_._v("node_modules")]),_._v(" 里面的文件看起来非常的直观.")]),_._v(" "),o("p",[o("img",{attrs:{src:e(538),alt:""}})]),_._v(" "),o("p",[_._v("同时,  "),o("code",[_._v("node_modules/.pnpm")]),_._v(" 中存储的文件其实是 "),o("code",[_._v("pnpm")]),_._v(" 实际缓存文件的 "),o("strong",[_._v("硬链接")]),_._v(" , 从而避免了多个项目带来多份相同文件引起的空间浪费问题.\n但是从 "),o("code",[_._v("pnpm")]),_._v(" 的 "),o("a",{attrs:{href:"https://pnpm.io/npmrc#package-import-method",target:"_blank",rel:"noopener noreferrer"}},[_._v("官网"),o("OutboundLink")],1),_._v(" 来看, 其实它默认会使用 "),o("code",[_._v("copy-on-write")]),_._v(" 的方式来进行处理, 也就是如果你尝试对内容进行修改的话, 会复制一份文件而不会影响到源文件.\n然后它不生效的原因似乎是因为 "),o("code",[_._v("libuv")]),_._v(" 的 "),o("a",{attrs:{href:"https://github.com/pnpm/pnpm/issues/2761",target:"_blank",rel:"noopener noreferrer"}},[_._v("bug"),o("OutboundLink")],1),_._v(". 所以在 "),o("code",[_._v("copy-on-write")]),_._v(" 不生效的情况下被回退到了 "),o("code",[_._v("hardlink")]),_._v(" 的方式去处理.")])])}),[],!1,null,null,null);v.default=n.exports}}]);